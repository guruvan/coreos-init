#!/bin/bash -x

get_ip () {
     IF=docker0
     DOCKER0_ADDR=
     while [ 1 ] 
     do
       DOCKER0_ADDR=$(ifconfig $IF | awk '/inet / {print $2}')
       if [ "$DOCKER0_ADDR" != "" ]; then
          break
       fi
       sleep .1
     done
}

set_net () {
  while [ 1 ]
  do
    net=$(etcdctl --no-sync -C http://127.0.0.1:4001 get /coreos.com/network/config)
    if [ "$net" != "" ]
    then
      . /etc/instance-id.env
      . /etc/environment
      etcdctl --no-sync -C http://127.0.0.1:4001 \
        set /skydns/config \
        '{"dns_addr":"0.0.0.0:53","ttl":300,"domain":"mazaclub", "nameservers": ["10.242.70.10","8.8.8.8:53","8.8.4.4:53"]}'
      etcdctl --no-sync -C http://127.0.0.1:4001 \
        set /skydns/${domain}/etcd/${INSTANCE_ID} \
        \{\"host\":\"${COREOS_PRIVATE_IPV4}\",\"port\":4001\}
     break
    fi
    sleep .1
done
}
check_ns () {
     good_ns=0
     ping -c1 -w3 etcd.${domain} && good_ns=1
     if [ "${good_ns}" -eq 1 ]
     then
       for i in $(etcdctl -C http://etcd.${domain} ls --recursive /skydns/${domain}/dns/ns) 
       do 
         etcdctl -C http://etcd.${domain}:4001 get ${i} | awk -F\" '{print $4}'|sort -u i>>/tmp/etcd-resolv
       done
       while read line
       do
        echo "nameserver ${line}" >> /opt/resolv.conf.etcd
       done < /tmp/etcd-resolv
     fi
}
get_ip
ETH0_ADDR=$(ifconfig eth0 | awk '/inet / {print $2}')
echo "ETH0_ADDR=${ETH0_ADDR}" >/etc/eth0.env
if [ -f /etc/docker.env ]
then
  sed -i '/DOCKER0_ADDR/d' /etc/docker.env
fi
echo "DOCKER0_ADDR=${DOCKER0_ADDR}" >> /tmp/docker.env
rvrse=$(echo $ETH0_ADDR |awk -F"." '{print $(NF-1)"-"$NF}')
echo "127.0.0.1 $(hostname)-${rvrse}" > /etc/hosts
#we set our hostnames in our aws launch configs, 
###hostname=$(curl http://169.254.169.254/latest/meta-data/local-hostname|awk -F"." '{print $(NF-1)}')
hostname $(hostname)-${rvrse}
echo "INSTANCE_ID=$(curl http://169.254.169.254/latest/meta-data/instance-id)" > /etc/instance-id.env
domain=$(curl http://169.254.169.254/latest/meta-data/local-hostname|awk -F"." '{print $NF}')
## we use a custom dynamic resolv.conf manager that runs along with our flannel-keepalive
## this provides the salt for that - DNS service is executed as 2 global units, every host has a local 
## skydns server, and service announcement for ns.dns.$DOMAIN - we keep a constant rotation 
## with an etcdctl exec-watch updating the resolv.conf. 
echo "nameserver ${ETH0_ADDR}" >> /opt/resolv.conf.local
echo "nameserver ${DOCKER0_ADDR}" >> /opt/resolv.conf.local
set_net
check_ns
echo "nameserver ${COREOS_PRIVATE_IPV4}" >> /opt/resolv.conf.local
sort -uR /opt/resolv.conf.etcd > /opt/resolv.conf
count=0
while read s
do
  s_g=$(echo ${s}|awk -F"." '{print $NF}')
  if [ -n "${s_g}" ]
  then count=$((count+1))
  fi
done < /opt/resolv.conf.etcd
if [ "$count" -ge 2 ]
then
  # save the bootstrap resolv.conf in case dns fails, resolvconf-mgr service 
  # should replace with this to start or restart skydns services
  cp /etc/resolv.conf /opt/resolv.conf.bootstrap
  rm /etc/resolv.conf && cp /opt/resolv.conf /etc/resolv.conf
  #still not protecting against empty nameserver lines in resolv.conf completely

fi
if [ -e /run/flannel/subnet.env ]
then
  cat /run/flannel/subnet.env  >> /etc/flannel-subnet.env
  cat /run/docker_opts.env /tmp/docker.env|sort -u > /etc/docker.env
fi
if [ -f /home/core/.dockercfg ]
then
  cp /home/core/.dockercfg /root
fi
if [ -f /etc/ssl/certs/privregistry.${domain} ]
then
  mkdir -pv /etc/docker/certs.d/privregistry.${domain} && cp /etc/ssl/certs/privregistry.${domain} /etc/docker/certs.d/privregistry.${domain}/ca.crt
fi


mkdir -p /opt/bin/

# Install fig
echo -n "Installing fig............ "
if [ -f "/opt/bin/fig" ]; then
        echo "[$(tput setaf 4)SKIP$(tput sgr 0)]"
else
        curl -sSL https://github.com/docker/fig/releases/download/1.0.1/fig-Linux-x86_64 > /opt/bin/fig
        chmod +x /opt/bin/fig
        echo "[$(tput setaf 2) OK $(tput sgr 0)]"
fi

# Install docker-sdlc
echo -n "Installing docker-sdlc.... "
if [ -d "/opt/docker-sdlc" ]
then
        cd /opt/docker-sdlc
        git fetch --all > /dev/null
        git reset --hard origin/master > /dev/null
        echo "[$(tput setaf 4)PULL$(tput sgr 0)]"
else
        git clone https://github.com/harbur/docker-sdlc.git /opt/docker-sdlc > /dev/null
        echo "[$(tput setaf 2) OK $(tput sgr 0)]"
fi

# Install docker-enter
echo -n "Installing docker-enter... "
if [ -f "/opt/bin/docker-enter" ]
then
        echo "[$(tput setaf 4)SKIP$(tput sgr 0)]"
else
        docker run -it --rm -v /opt/bin:/target jpetazzo/nsenter && docker rmi jpetazzo/nsenter
        echo "[$(tput setaf 2) OK $(tput sgr 0)]"
fi

if [ ! -f /tmp/installed.skydns ]
then
         /usr/bin/docker pull guruvan/docker-skydns && touch /tmp/installed.skydns
fi

if [ ! -f /tmp/installed.skydns ]
then
        /usr/bin/docker pull guruvan/flannel-keepalive && touch /tmp/installed.keepalive
fi

if [ ! -f /tmp/installed.skydns ]
then
        /usr/bin/docker pull shastafareye/docker-skydns-announce && touch /tmp/installed.skydns-ann
fi

touch /tmp/installed.coreos-init
echo "Finished coreos-init install"
exit
